generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                          String                       @id @default(uuid())
  email                       String                       @unique
  password                    String
  name                        String?
  companyName                 String?
  companyLegalName            String?
  companyTaxId                String?
  companyStateRegistration    String?
  companyWhatsapp             String?
  companyAddress              Json?
  companyBranding             Json?
  phone                       String?
  language                    String?                      @default("pt-BR")
  timezone                    String?                      @default("America/Sao_Paulo")
  role                        UserRole                     @default(USER)
  planId                      String?
  googleId                    String?                      @unique
  avatarUrl                   String?
  companyLogoUrl              String?
  // Pix payment settings
  pixKey                      String?
  pixKeyType                  String?                      // CPF, CNPJ, EMAIL, PHONE, RANDOM
  pixKeyOwnerName             String?
  pixKeyEnabled               Boolean                      @default(false)
  createdAt                   DateTime                     @default(now())
  updatedAt                   DateTime                     @updatedAt
  asaasIntegration            AsaasIntegration?
  createdAttachments          Attachment[]                 @relation("AttachmentCreator")
  attachments                 Attachment[]                 @relation("UserAttachments")
  bundleItems                 BundleItem[]
  checklistTemplates          ChecklistTemplate[]
  clientPayments              ClientPayment[]
  clients                     Client[]
  devices                     Device[]
  domainEvents                DomainEvent[]
  equipment                   Equipment[]
  expenses                    Expense[]
  expenseCategories           ExpenseCategory[]
  financialAutomationSettings FinancialAutomationSettings?
  importJobs                  ImportJob[]
  invoices                    Invoice[]
  items                       Item[]
  notificationLogs            NotificationLog[]
  notificationPreferences     NotificationPreferences?
  pdfJobs                     PdfJob[]
  productCategories           ProductCategory[]
  quotes                      Quote[]
  signatures                  Signature[]
  suppliers                   Supplier[]
  syncLogs                    SyncLog[]
  templateSettings            TemplateSettings?
  subscription                UserSubscription?
  plan                        Plan?                        @relation(fields: [planId], references: [id])
  workOrders                  WorkOrder[]
  workOrderTypes              WorkOrderType[]
  inventorySettings           InventorySettings?

  @@map("users")
}

model Plan {
  id            String             @id @default(uuid())
  type          PlanType           @unique
  name          String
  description   String?
  price         Decimal            @db.Decimal(10, 2)
  yearlyPrice   Decimal?           @db.Decimal(10, 2)
  maxClients    Int
  maxQuotes     Int
  maxWorkOrders Int
  maxInvoices   Int
  features      String[]           @default([])
  isActive      Boolean            @default(true)
  createdAt     DateTime           @default(now())
  updatedAt     DateTime           @updatedAt
  usageLimits   UsageLimitsConfig?
  subscriptions UserSubscription[]
  users         User[]

  @@map("plans")
}

model UserSubscription {
  id                  String                       @id @default(uuid())
  userId              String                       @unique
  planId              String
  asaasCustomerId     String?
  asaasSubscriptionId String?
  asaasPaymentId      String?
  status              SubscriptionStatus           @default(ACTIVE)
  billingPeriod       BillingPeriod                @default(MONTHLY)
  currentPeriodStart  DateTime?
  currentPeriodEnd    DateTime?
  trialEndAt          DateTime?
  canceledAt          DateTime?
  cancelAtPeriodEnd   Boolean                      @default(false)
  paymentMethod       PaymentMethod?
  lastPaymentDate     DateTime?
  overdueAt           DateTime?
  retryCount          Int                          @default(0)
  lastRetryAt         DateTime?
  blockedAt           DateTime?
  blockReason         String?
  creditCardToken     String?
  creditCardLastFour  String?
  creditCardBrand     String?
  createdAt           DateTime                     @default(now())
  updatedAt           DateTime                     @updatedAt
  paymentHistory      SubscriptionPaymentHistory[]
  plan                Plan                         @relation(fields: [planId], references: [id])
  user                User                         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([planId])
  @@index([status])
  @@index([asaasCustomerId])
  @@index([asaasSubscriptionId])
  @@index([overdueAt])
  @@index([blockedAt])
  @@map("user_subscriptions")
}

model SubscriptionPaymentHistory {
  id             String           @id @default(uuid())
  subscriptionId String
  asaasPaymentId String?
  amount         Decimal          @db.Decimal(10, 2)
  paymentMethod  PaymentMethod
  status         PaymentStatus
  paidAt         DateTime?
  dueDate        DateTime
  pixQrCode      String?
  pixCopyPaste   String?
  pixExpiresAt   DateTime?
  errorMessage   String?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  subscription   UserSubscription @relation(fields: [subscriptionId], references: [id], onDelete: Cascade)

  @@index([subscriptionId])
  @@index([asaasPaymentId])
  @@index([status])
  @@index([dueDate])
  @@map("subscription_payment_history")
}

model UsageLimitsConfig {
  id                        String   @id @default(uuid())
  planId                    String   @unique
  maxClients                Int      @default(-1)
  maxQuotes                 Int      @default(-1)
  maxWorkOrders             Int      @default(-1)
  maxPayments               Int      @default(-1)
  maxNotificationsPerMonth  Int      @default(-1)
  maxSuppliers              Int      @default(-1)
  maxExpenses               Int      @default(-1)
  enableAdvancedAutomations Boolean  @default(false)
  enableAdvancedAnalytics   Boolean  @default(false)
  enableClientPortal        Boolean  @default(false)
  enablePdfExport           Boolean  @default(true)
  enableDigitalSignature    Boolean  @default(false)
  enableWhatsApp            Boolean  @default(false)
  enableExpenseManagement   Boolean  @default(false)
  enablePixKey              Boolean  @default(true)   // Pix key feature - default true for all plans
  enableWorkOrderTypes      Boolean  @default(false)  // Work order types feature - default false
  enableInventory           Boolean  @default(false)  // Inventory/stock control feature - default false
  enableAcceptanceTerms     Boolean  @default(false)  // Acceptance terms for quote signatures - paid plans only
  createdAt                 DateTime @default(now())
  updatedAt                 DateTime @updatedAt
  plan                      Plan     @relation(fields: [planId], references: [id], onDelete: Cascade)

  @@index([planId])
  @@map("usage_limits_config")
}

model Client {
  id               String            @id @default(uuid())
  userId           String
  name             String
  email            String?
  phone            String?
  address          String?
  city             String?
  state            String?
  zipCode          String?
  taxId            String?
  notes            String?
  asaasCustomerId  String?
  isDelinquent     Boolean           @default(false)
  delinquentAt     DateTime?
  deletedAt        DateTime?
  createdAt        DateTime          @default(now())
  updatedAt        DateTime          @updatedAt
  attachments      Attachment[]
  payments         ClientPayment[]
  user             User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  equipment        Equipment[]
  invoices         Invoice[]
  notificationLogs NotificationLog[]
  quotes           Quote[]
  signatures       Signature[]
  workOrders       WorkOrder[]

  @@index([userId])
  @@index([asaasCustomerId])
  @@index([isDelinquent])
  @@index([updatedAt])
  @@index([deletedAt])
  @@map("clients")
}

model ProductCategory {
  id          String   @id @default(uuid())
  userId      String
  name        String
  description String?
  color       String?
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  items       Item[]
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("product_categories")
}

model Item {
  id                     String            @id @default(uuid())
  userId                 String
  categoryId             String?
  name                   String
  description            String?
  type                   ItemType          @default(PRODUCT)
  sku                    String?
  unit                   String            @default("UN")
  basePrice              Decimal           @db.Decimal(10, 2)
  costPrice              Decimal?          @db.Decimal(10, 2)
  defaultDurationMinutes Int?
  isActive               Boolean           @default(true)
  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt
  bundleAsParent         BundleItem[]      @relation("BundleParent")
  bundleAsChild          BundleItem[]      @relation("BundleChild")
  category               ProductCategory?  @relation(fields: [categoryId], references: [id])
  user                   User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  quoteItems             QuoteItem[]
  workOrderItems         WorkOrderItem[]
  inventoryBalance       InventoryBalance?

  @@index([userId])
  @@index([categoryId])
  @@index([type])
  @@index([sku])
  @@index([isActive])
  @@map("items")
}

model BundleItem {
  id        String   @id @default(uuid())
  userId    String
  bundleId  String
  itemId    String
  quantity  Decimal  @default(1) @db.Decimal(10, 3)
  createdAt DateTime @default(now())
  bundle    Item     @relation("BundleParent", fields: [bundleId], references: [id], onDelete: Cascade)
  item      Item     @relation("BundleChild", fields: [itemId], references: [id], onDelete: Cascade)
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([bundleId, itemId])
  @@index([userId])
  @@index([bundleId])
  @@index([itemId])
  @@map("bundle_items")
}

model Equipment {
  id                  String               @id @default(uuid())
  userId              String
  clientId            String
  type                String
  brand               String?
  model               String?
  serialNumber        String?
  installationDate    DateTime?
  warrantyEndDate     DateTime?
  notes               String?
  createdAt           DateTime             @default(now())
  updatedAt           DateTime             @updatedAt
  client              Client               @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user                User                 @relation(fields: [userId], references: [id], onDelete: Cascade)
  workOrderEquipments WorkOrderEquipment[]

  @@index([userId])
  @@index([clientId])
  @@map("equipment")
}

model Quote {
  id               String          @id @default(uuid())
  userId           String
  clientId         String
  status           QuoteStatus     @default(DRAFT)
  discountValue    Decimal         @default(0) @db.Decimal(15, 2)
  totalValue       Decimal         @db.Decimal(15, 2)
  notes            String?
  sentAt           DateTime?
  visitScheduledAt DateTime?
  shareKey         String?         @unique
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt
  attachments      Attachment[]
  clientPayments   ClientPayment[]
  items            QuoteItem[]
  client           Client          @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user             User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  signatures       Signature[]
  workOrder        WorkOrder?

  @@index([userId])
  @@index([clientId])
  @@index([status])
  @@index([sentAt])
  @@index([visitScheduledAt])
  @@map("quotes")
}

model QuoteItem {
  id             String          @id @default(uuid())
  quoteId        String
  itemId         String?
  name           String
  type           ItemType        @default(PRODUCT)
  unit           String          @default("UN")
  quantity       Decimal         @db.Decimal(10, 3)
  unitPrice      Decimal         @db.Decimal(15, 2)
  discountValue  Decimal         @default(0) @db.Decimal(15, 2)
  totalPrice     Decimal         @db.Decimal(15, 2)
  createdAt      DateTime        @default(now())
  updatedAt      DateTime        @updatedAt
  item           Item?           @relation(fields: [itemId], references: [id])
  quote          Quote           @relation(fields: [quoteId], references: [id], onDelete: Cascade)
  workOrderItems WorkOrderItem[]

  @@index([quoteId])
  @@index([itemId])
  @@map("quote_items")
}

model WorkOrderType {
  id          String      @id @default(uuid())
  userId      String
  name        String
  description String?
  color       String?
  isActive    Boolean     @default(true)
  createdAt   DateTime    @default(now())
  updatedAt   DateTime    @updatedAt
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  workOrders  WorkOrder[]

  @@unique([userId, name])
  @@index([userId])
  @@index([isActive])
  @@index([updatedAt])
  @@map("work_order_types")
}

model WorkOrder {
  id                   String                        @id @default(uuid())
  userId               String
  clientId             String
  quoteId              String?                       @unique
  workOrderTypeId      String?
  title                String
  description          String?
  status               WorkOrderStatus               @default(SCHEDULED)
  scheduledDate        DateTime?
  scheduledStartTime   DateTime?
  scheduledEndTime     DateTime?
  executionStart       DateTime?
  executionEnd         DateTime?
  address              String?
  notes                String?
  totalValue           Decimal?                      @db.Decimal(15, 2)
  shareKey             String?                       @unique
  createdAt            DateTime                      @default(now())
  updatedAt            DateTime                      @updatedAt
  attachments          Attachment[]
  checklistInstances   ChecklistInstance[]
  expenses             Expense[]
  payments             ClientPayment[]
  invoice              Invoice?
  signatures           Signature[]
  checklists           WorkOrderChecklist[]
  equipments           WorkOrderEquipment[]
  executionSessions    WorkOrderExecutionSession[]
  items                WorkOrderItem[]
  client               Client                        @relation(fields: [clientId], references: [id], onDelete: Cascade)
  quote                Quote?                        @relation(fields: [quoteId], references: [id])
  user                 User                          @relation(fields: [userId], references: [id], onDelete: Cascade)
  workOrderType        WorkOrderType?                @relation(fields: [workOrderTypeId], references: [id], onDelete: SetNull)
  inventoryDeductions  WorkOrderInventoryDeduction[]

  @@index([userId])
  @@index([clientId])
  @@index([status])
  @@index([workOrderTypeId])
  @@index([userId, workOrderTypeId])
  @@index([userId, createdAt])
  @@map("work_orders")
}

model WorkOrderExecutionSession {
  id           String               @id @default(uuid())
  workOrderId  String
  technicianId String
  sessionType  ExecutionSessionType
  startedAt    DateTime
  endedAt      DateTime?
  duration     Int?
  pauseReason  String?
  notes        String?
  localId      String?
  createdAt    DateTime             @default(now())
  updatedAt    DateTime             @updatedAt
  workOrder    WorkOrder            @relation(fields: [workOrderId], references: [id], onDelete: Cascade)

  @@index([workOrderId])
  @@index([technicianId])
  @@index([localId])
  @@map("work_order_execution_sessions")
}

model WorkOrderItem {
  id            String     @id @default(uuid())
  workOrderId   String
  quoteItemId   String?
  itemId        String?
  name          String
  type          ItemType   @default(PRODUCT)
  unit          String     @default("UN")
  quantity      Decimal    @db.Decimal(10, 3)
  unitPrice     Decimal    @db.Decimal(15, 2)
  discountValue Decimal    @default(0) @db.Decimal(15, 2)
  totalPrice    Decimal    @db.Decimal(15, 2)
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt
  item          Item?      @relation(fields: [itemId], references: [id])
  quoteItem     QuoteItem? @relation(fields: [quoteItemId], references: [id])
  workOrder     WorkOrder  @relation(fields: [workOrderId], references: [id], onDelete: Cascade)

  @@index([workOrderId])
  @@index([quoteItemId])
  @@index([itemId])
  @@map("work_order_items")
}

model WorkOrderEquipment {
  id          String    @id @default(uuid())
  workOrderId String
  equipmentId String
  createdAt   DateTime  @default(now())
  equipment   Equipment @relation(fields: [equipmentId], references: [id], onDelete: Cascade)
  workOrder   WorkOrder @relation(fields: [workOrderId], references: [id], onDelete: Cascade)

  @@index([workOrderId])
  @@index([equipmentId])
  @@map("work_order_equipments")
}

model ChecklistTemplate {
  id          String              @id @default(uuid())
  userId      String
  name        String
  description String?
  version     Int                 @default(1)
  isActive    Boolean             @default(true)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  instances   ChecklistInstance[]
  questions   ChecklistQuestion[]
  sections    ChecklistSection[]
  user        User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([isActive])
  @@map("checklist_templates")
}

model ChecklistSection {
  id          String              @id @default(uuid())
  templateId  String
  title       String
  description String?
  order       Int                 @default(0)
  createdAt   DateTime            @default(now())
  updatedAt   DateTime            @updatedAt
  questions   ChecklistQuestion[]
  template    ChecklistTemplate   @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@index([templateId])
  @@map("checklist_sections")
}

model ChecklistQuestion {
  id               String                @id @default(uuid())
  templateId       String
  sectionId        String?
  type             ChecklistQuestionType
  title            String
  description      String?
  placeholder      String?
  isRequired       Boolean               @default(false)
  order            Int                   @default(0)
  options          Json?
  validations      Json?
  conditionalLogic Json?
  metadata         Json?
  createdAt        DateTime              @default(now())
  updatedAt        DateTime              @updatedAt
  answers          ChecklistAnswer[]
  section          ChecklistSection?     @relation(fields: [sectionId], references: [id])
  template         ChecklistTemplate     @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@index([templateId])
  @@index([sectionId])
  @@map("checklist_questions")
}

model ChecklistInstance {
  id                      String                  @id @default(uuid())
  workOrderId             String
  templateId              String
  templateVersionSnapshot Json
  status                  ChecklistInstanceStatus @default(PENDING)
  startedAt               DateTime?
  completedAt             DateTime?
  completedBy             String?
  progress                Int                     @default(0)
  createdAt               DateTime                @default(now())
  updatedAt               DateTime                @updatedAt
  answers                 ChecklistAnswer[]
  template                ChecklistTemplate       @relation(fields: [templateId], references: [id])
  workOrder               WorkOrder               @relation(fields: [workOrderId], references: [id], onDelete: Cascade)

  @@index([workOrderId])
  @@index([templateId])
  @@index([status])
  @@map("checklist_instances")
}

model ChecklistAnswer {
  id           String                @id @default(uuid())
  instanceId   String
  questionId   String
  type         ChecklistQuestionType
  valueText    String?
  valueNumber  Decimal?              @db.Decimal(15, 4)
  valueBoolean Boolean?
  valueDate    DateTime?
  valueJson    Json?
  answeredAt   DateTime              @default(now())
  answeredBy   String?
  deviceInfo   String?
  syncedAt     DateTime?
  localId      String?
  createdAt    DateTime              @default(now())
  updatedAt    DateTime              @updatedAt
  instance     ChecklistInstance     @relation(fields: [instanceId], references: [id], onDelete: Cascade)
  question     ChecklistQuestion     @relation(fields: [questionId], references: [id])
  attachments  ChecklistAttachment[]

  @@unique([instanceId, questionId])
  @@index([instanceId])
  @@index([questionId])
  @@index([localId])
  @@map("checklist_answers")
}

model ChecklistAttachment {
  id            String                  @id @default(uuid())
  answerId      String
  type          ChecklistAttachmentType
  fileName      String
  fileSize      Int
  mimeType      String
  storagePath   String
  publicUrl     String?
  thumbnailPath String?
  thumbnailUrl  String?
  metadata      Json?
  uploadedAt    DateTime                @default(now())
  uploadedBy    String?
  syncStatus    AttachmentSyncStatus    @default(SYNCED)
  localPath     String?
  createdAt     DateTime                @default(now())
  answer        ChecklistAnswer         @relation(fields: [answerId], references: [id], onDelete: Cascade)

  @@index([answerId])
  @@index([syncStatus])
  @@map("checklist_attachments")
}

model WorkOrderChecklist {
  id          String                     @id @default(uuid())
  workOrderId String
  templateId  String
  title       String
  createdAt   DateTime                   @default(now())
  updatedAt   DateTime                   @updatedAt
  answers     WorkOrderChecklistAnswer[]
  workOrder   WorkOrder                  @relation(fields: [workOrderId], references: [id], onDelete: Cascade)

  @@index([workOrderId])
  @@index([templateId])
  @@map("work_order_checklists")
}

model WorkOrderChecklistAnswer {
  id                   String             @id @default(uuid())
  workOrderChecklistId String
  templateItemId       String
  type                 ChecklistItemType
  valueText            String?
  valueNumber          Decimal?           @db.Decimal(10, 3)
  valueBoolean         Boolean?
  valuePhoto           String?
  valueSelect          String?
  createdAt            DateTime           @default(now())
  updatedAt            DateTime           @updatedAt
  checklist            WorkOrderChecklist @relation(fields: [workOrderChecklistId], references: [id], onDelete: Cascade)

  @@unique([workOrderChecklistId, templateItemId])
  @@index([workOrderChecklistId])
  @@index([templateItemId])
  @@map("work_order_checklist_answers")
}

model Invoice {
  id            String        @id @default(uuid())
  userId        String
  clientId      String
  workOrderId   String?       @unique
  invoiceNumber String        @unique
  status        InvoiceStatus @default(PENDING)
  subtotal      Decimal       @db.Decimal(15, 2)
  discount      Decimal       @default(0) @db.Decimal(15, 2)
  tax           Decimal       @default(0) @db.Decimal(15, 2)
  total         Decimal       @db.Decimal(15, 2)
  dueDate       DateTime
  paidDate      DateTime?
  notes         String?
  createdAt     DateTime      @default(now())
  updatedAt     DateTime      @updatedAt
  client        Client        @relation(fields: [clientId], references: [id], onDelete: Cascade)
  user          User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  workOrder     WorkOrder?    @relation(fields: [workOrderId], references: [id])

  @@index([userId])
  @@index([clientId])
  @@map("invoices")
}

model AsaasIntegration {
  id              String           @id @default(uuid())
  userId          String           @unique
  apiKeyEncrypted String
  environment     AsaasEnvironment @default(SANDBOX)
  isActive        Boolean          @default(true)
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  user            User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("asaas_integrations")
}

model ClientPayment {
  id              String             @id @default(uuid())
  userId          String
  clientId        String
  quoteId         String?
  workOrderId     String?
  asaasPaymentId  String             @unique
  billingType     PaymentBillingType
  value           Decimal            @db.Decimal(15, 2)
  description     String?
  dueDate         DateTime
  status          PaymentStatus      @default(PENDING)
  asaasInvoiceUrl String?
  asaasQrCodeUrl  String?
  asaasPixCode    String?
  paidAt          DateTime?
  canceledAt      DateTime?
  createdAt       DateTime           @default(now())
  updatedAt       DateTime           @updatedAt
  publicToken     String?            @unique @default(uuid())
  client          Client             @relation(fields: [clientId], references: [id], onDelete: Cascade)
  quote           Quote?             @relation(fields: [quoteId], references: [id])
  user            User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  workOrder       WorkOrder?         @relation(fields: [workOrderId], references: [id])

  @@index([userId])
  @@index([clientId])
  @@index([asaasPaymentId])
  @@index([status])
  @@index([dueDate])
  @@index([paidAt])
  @@index([billingType])
  @@index([userId, status])
  @@index([userId, dueDate])
  @@index([userId, paidAt])
  @@index([publicToken])
  @@map("client_payments")
}

model FinancialAutomationSettings {
  id                                   String   @id @default(uuid())
  userId                               String   @unique
  isEnabled                            Boolean  @default(true)
  paymentReminderDaysBefore            Int[]    @default([3, 1])
  paymentReminderDaysAfter             Int[]    @default([3, 7])
  autoMarkOverdueAsDelinquentAfterDays Int?     @default(30)
  enableQuoteFollowUp                  Boolean  @default(true)
  quoteFollowUpDays                    Int[]    @default([3, 7])
  autoCancelPaymentAfterDays           Int?
  createdAt                            DateTime @default(now())
  updatedAt                            DateTime @updatedAt
  user                                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("financial_automation_settings")
}

model NotificationPreferences {
  id                         String   @id @default(uuid())
  userId                     String   @unique
  notifyOnQuoteSent          Boolean  @default(true)
  notifyOnQuoteApproved      Boolean  @default(true)
  notifyOnWorkOrderCreated   Boolean  @default(true)
  notifyOnWorkOrderCompleted Boolean  @default(true)
  notifyOnPaymentCreated     Boolean  @default(true)
  notifyOnPaymentConfirmed   Boolean  @default(true)
  notifyOnPaymentOverdue     Boolean  @default(true)
  defaultChannelEmail        Boolean  @default(true)
  defaultChannelWhatsApp     Boolean  @default(true)
  createdAt                  DateTime @default(now())
  updatedAt                  DateTime @updatedAt
  user                       User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("notification_preferences")
}

model NotificationLog {
  id              String              @id @default(uuid())
  userId          String
  clientId        String?
  workOrderId     String?
  quoteId         String?
  clientPaymentId String?
  channel         NotificationChannel
  type            NotificationType
  recipient       String
  subject         String?
  body            String
  payload         Json?
  status          NotificationStatus
  errorMessage    String?
  createdAt       DateTime            @default(now())
  client          Client?             @relation(fields: [clientId], references: [id])
  user            User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([clientId])
  @@index([type])
  @@index([status])
  @@index([createdAt])
  @@map("notification_logs")
}

model Attachment {
  id               String         @id @default(uuid())
  userId           String
  clientId         String?
  quoteId          String?
  workOrderId      String?
  type             AttachmentType
  mimeType         String
  fileNameOriginal String
  fileSize         Int
  storagePath      String
  publicUrl        String?
  metadata         Json?
  createdAt        DateTime       @default(now())
  createdByUserId  String
  client           Client?        @relation(fields: [clientId], references: [id])
  createdBy        User           @relation("AttachmentCreator", fields: [createdByUserId], references: [id], onDelete: Cascade)
  quote            Quote?         @relation(fields: [quoteId], references: [id])
  user             User           @relation("UserAttachments", fields: [userId], references: [id], onDelete: Cascade)
  workOrder        WorkOrder?     @relation(fields: [workOrderId], references: [id])
  pdfJob           PdfJob?
  publicLinks      PublicLink[]
  signatures       Signature[]

  @@index([userId])
  @@index([clientId])
  @@index([quoteId])
  @@index([workOrderId])
  @@index([type])
  @@index([createdAt])
  @@map("attachments")
}

model PublicLink {
  id           String     @id @default(uuid())
  attachmentId String
  token        String     @unique
  expiresAt    DateTime?
  accessCount  Int        @default(0)
  lastAccessAt DateTime?
  createdAt    DateTime   @default(now())
  attachment   Attachment @relation(fields: [attachmentId], references: [id], onDelete: Cascade)

  @@index([attachmentId])
  @@index([token])
  @@index([expiresAt])
  @@map("public_links")
}

model Signature {
  id              String     @id @default(uuid())
  userId          String
  clientId        String
  workOrderId     String?
  quoteId         String?
  attachmentId    String
  signerName      String
  signerDocument  String?
  signerRole      String?
  ipAddress       String?
  userAgent       String?
  signedAt        DateTime   @default(now())
  hash            String?
  localId         String?
  // Acceptance Terms audit fields
  termsAcceptedAt DateTime?
  termsHash       String?
  termsVersion    Int?
  attachment      Attachment @relation(fields: [attachmentId], references: [id], onDelete: Cascade)
  client          Client     @relation(fields: [clientId], references: [id], onDelete: Cascade)
  quote           Quote?     @relation(fields: [quoteId], references: [id])
  user            User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  workOrder       WorkOrder? @relation(fields: [workOrderId], references: [id])

  @@index([userId])
  @@index([clientId])
  @@index([workOrderId])
  @@index([quoteId])
  @@index([attachmentId])
  @@index([localId])
  @@map("signatures")
}

model SyncLog {
  id           String   @id @default(uuid())
  userId       String
  entity       String
  entityId     String
  action       String
  status       String
  errorMessage String?
  syncedAt     DateTime @default(now())
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([entity])
  @@map("sync_logs")
}

model ProcessedMutation {
  id          String   @id @default(uuid())
  mutationId  String   @unique
  userId      String
  entity      String
  entityId    String
  action      String
  status      String
  resultData  Json?
  processedAt DateTime @default(now())

  @@index([userId])
  @@index([mutationId])
  @@index([entity])
  @@index([processedAt])
  @@map("processed_mutations")
}

model PdfJob {
  id             String        @id @default(uuid())
  userId         String
  entityType     PdfEntityType
  entityId       String
  status         PdfJobStatus  @default(PENDING)
  priority       Int           @default(0)
  attempts       Int           @default(0)
  maxAttempts    Int           @default(3)
  attachmentId   String?       @unique
  errorMessage   String?
  bullJobId      String?
  processingTime Int?
  fileSize       Int?
  requestedAt    DateTime      @default(now())
  startedAt      DateTime?
  completedAt    DateTime?
  failedAt       DateTime?
  metadata       Json?
  attachment     Attachment?   @relation(fields: [attachmentId], references: [id])
  user           User          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([entityType, entityId])
  @@index([status])
  @@index([bullJobId])
  @@index([requestedAt])
  @@map("pdf_jobs")
}

model ImportJob {
  id            String          @id @default(uuid())
  userId        String
  fileName      String
  fileSize      Int
  totalRows     Int             @default(0)
  processedRows Int             @default(0)
  successCount  Int             @default(0)
  errorCount    Int             @default(0)
  status        ImportJobStatus @default(PENDING)
  errorDetails  Json?
  createdAt     DateTime        @default(now())
  startedAt     DateTime?
  completedAt   DateTime?
  user          User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([createdAt])
  @@map("import_jobs")
}

model TemplateSettings {
  id                          String    @id @default(uuid())
  userId                      String    @unique
  quoteShowLogo               Boolean   @default(true)
  quoteLogoPosition           String    @default("left")
  quotePrimaryColor           String    @default("#7C3AED")
  quoteSecondaryColor         String    @default("#6D28D9")
  quoteHeaderText             String?
  quoteFooterText             String    @default("Obrigado pela preferÃªncia!")
  quoteDefaultMessage         String    @default("Segue nosso orÃ§amento conforme solicitado.")
  quoteTermsConditions        String?
  quoteShowSignature          Boolean   @default(false)
  // Acceptance Terms - requires paid plan
  acceptanceTermsEnabled      Boolean   @default(false)
  acceptanceTermsUpdatedAt    DateTime?
  acceptanceTermsVersion      Int       @default(0)
  workOrderShowLogo           Boolean   @default(true)
  workOrderLogoPosition       String    @default("left")
  workOrderPrimaryColor       String    @default("#7C3AED")
  workOrderLayout             String    @default("detailed")
  workOrderShowChecklist      Boolean   @default(true)
  workOrderFooterText         String?
  workOrderShowSignatureField Boolean   @default(true)
  workOrderSignatureLabel     String    @default("Assinatura do Cliente")
  invoiceShowLogo             Boolean   @default(true)
  invoiceLogoPosition         String    @default("left")
  invoicePrimaryColor         String    @default("#7C3AED")
  invoiceSecondaryColor       String    @default("#6D28D9")
  invoiceHeaderText           String?
  invoiceFooterText           String    @default("Obrigado pela preferÃªncia!")
  invoiceShowPaymentInfo      Boolean   @default(true)
  invoiceShowDueDate          Boolean   @default(true)
  chargeWhatsappMessage       String    @default("OlÃ¡ {nome_cliente}! ðŸ‘‹\n\nSegue sua cobranÃ§a:\n\nðŸ’° *Valor:* {valor}\nðŸ“… *Vencimento:* {data}\n\nðŸ”— *Link para pagamento:*\n{link_pagamento}\n\nQualquer dÃºvida, estou Ã  disposiÃ§Ã£o! ðŸ˜Š")
  chargeEmailSubject          String    @default("CobranÃ§a - {valor}")
  chargeEmailBody             String?
  chargeReminderMessage       String    @default("OlÃ¡ {nome_cliente}, lembramos que seu pagamento no valor de {valor} vence em {data}.\nSe jÃ¡ pagou, desconsidere esta mensagem.")
  createdAt                   DateTime  @default(now())
  updatedAt                   DateTime  @updatedAt
  user                        User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("template_settings")
}

model Device {
  id            String         @id @default(uuid())
  userId        String
  platform      DevicePlatform
  expoPushToken String         @unique
  appVersion    String?
  deviceModel   String?
  osVersion     String?
  isActive      Boolean        @default(true)
  lastSeenAt    DateTime       @default(now())
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt
  user          User           @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expoPushToken])
  @@map("devices")
}

model DomainEvent {
  id           String            @id @default(uuid())
  type         String
  entity       String
  entityId     String
  targetUserId String
  payload      Json?
  status       DomainEventStatus @default(PENDING)
  retryCount   Int               @default(0)
  lastError    String?
  dispatchedAt DateTime?
  createdAt    DateTime          @default(now())
  updatedAt    DateTime          @updatedAt
  targetUser   User              @relation(fields: [targetUserId], references: [id], onDelete: Cascade)

  @@index([targetUserId])
  @@index([status])
  @@index([createdAt])
  @@map("domain_events")
}

enum UserRole {
  ADMIN
  USER
}

enum PlanType {
  FREE
  PRO
  TEAM
}

enum PaymentMethod {
  PIX
  CREDIT_CARD
}

enum SubscriptionStatus {
  ACTIVE
  PAST_DUE
  CANCELED
  TRIALING
  BLOCKED
}

enum BillingPeriod {
  MONTHLY
  YEARLY
}

enum ItemType {
  PRODUCT
  SERVICE
  BUNDLE
}

enum QuoteStatus {
  DRAFT
  SENT
  APPROVED
  REJECTED
  EXPIRED
}

enum WorkOrderStatus {
  SCHEDULED
  IN_PROGRESS
  DONE
  CANCELED
}

enum ExecutionSessionType {
  WORK
  PAUSE
}

enum ChecklistQuestionType {
  TEXT_SHORT
  TEXT_LONG
  NUMBER
  DATE
  TIME
  DATETIME
  CHECKBOX
  SELECT
  MULTI_SELECT
  PHOTO_REQUIRED
  PHOTO_OPTIONAL
  FILE_UPLOAD
  SIGNATURE_TECHNICIAN
  SIGNATURE_CLIENT
  SECTION_TITLE
  RATING
  SCALE
}

enum ConditionOperator {
  EQUALS
  NOT_EQUALS
  GREATER_THAN
  LESS_THAN
  GREATER_THAN_OR_EQUAL
  LESS_THAN_OR_EQUAL
  CONTAINS
  NOT_CONTAINS
  IS_EMPTY
  IS_NOT_EMPTY
  IN
  NOT_IN
}

enum ConditionAction {
  SHOW
  HIDE
  REQUIRE
  SKIP_TO
}

enum ChecklistInstanceStatus {
  PENDING
  IN_PROGRESS
  COMPLETED
  CANCELLED
}

enum ChecklistAttachmentType {
  PHOTO
  DOCUMENT
  SIGNATURE
  VIDEO
  AUDIO
}

enum AttachmentSyncStatus {
  PENDING
  UPLOADING
  SYNCED
  FAILED
}

enum ChecklistItemType {
  TEXT
  NUMERIC
  BOOLEAN
  PHOTO
  SELECT
}

enum InvoiceStatus {
  PENDING
  PAID
  OVERDUE
  CANCELLED
}

enum AsaasEnvironment {
  SANDBOX
  PRODUCTION
}

enum PaymentBillingType {
  BOLETO
  PIX
  CREDIT_CARD
}

enum PaymentStatus {
  PENDING
  CONFIRMED
  RECEIVED
  OVERDUE
  REFUNDED
  DELETED
  RECEIVED_IN_CASH
  REFUND_REQUESTED
  REFUND_IN_PROGRESS
  PARTIALLY_REFUNDED
  CHARGEBACK_REQUESTED
  CHARGEBACK_DISPUTE
  AWAITING_CHARGEBACK_REVERSAL
  DUNNING_REQUESTED
  DUNNING_RECEIVED
  AWAITING_RISK_ANALYSIS
  AUTHORIZED
  FAILED
  CANCELED
}

enum NotificationChannel {
  EMAIL
  WHATSAPP
}

enum NotificationType {
  QUOTE_SENT
  QUOTE_APPROVED
  QUOTE_FOLLOW_UP
  WORK_ORDER_CREATED
  WORK_ORDER_COMPLETED
  PAYMENT_CREATED
  PAYMENT_CONFIRMED
  PAYMENT_OVERDUE
  PAYMENT_REMINDER_BEFORE_DUE
  PAYMENT_REMINDER_AFTER_DUE
}

enum NotificationStatus {
  SENT
  FAILED
}

enum AttachmentType {
  PHOTO
  DOCUMENT
  SIGNATURE
}

enum PdfEntityType {
  QUOTE
  WORK_ORDER
  INVOICE
}

enum PdfJobStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  CANCELLED
}

enum ImportJobStatus {
  PENDING
  VALIDATING
  PROCESSING
  COMPLETED
  FAILED
}

enum DevicePlatform {
  IOS
  ANDROID
}

enum DomainEventStatus {
  PENDING
  SENT
  FAILED
}

// =============================================================================
// ACCOUNTS PAYABLE MODULE (Contas a Pagar / Despesas)
// =============================================================================

enum ExpenseStatus {
  DRAFT
  PENDING
  PAID
  CANCELED
  // OVERDUE Ã© calculado dinamicamente (dueDate < hoje AND status NOT IN [PAID, CANCELED])
}

enum ExpensePaymentMethod {
  PIX
  CREDIT_CARD
  DEBIT_CARD
  CASH
  BANK_TRANSFER
  BOLETO
  OTHER
}

model Supplier {
  id        String    @id @default(uuid())
  userId    String
  name      String
  document  String?   // CPF/CNPJ
  email     String?
  phone     String?
  address   String?
  notes     String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expenses Expense[]

  @@index([userId])
  @@index([userId, deletedAt])
  @@index([name])
  @@map("suppliers")
}

model ExpenseCategory {
  id        String   @id @default(uuid())
  userId    String
  name      String
  color     String?  // hex color para UI
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user     User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  expenses Expense[]

  @@unique([userId, name])
  @@index([userId])
  @@map("expense_categories")
}

model Expense {
  id            String                @id @default(uuid())
  userId        String
  supplierId    String?
  categoryId    String?
  workOrderId   String?               // VÃ­nculo opcional com OS para cÃ¡lculo de lucro
  description   String
  notes         String?
  amount        Decimal               @db.Decimal(15, 2)
  dueDate       DateTime
  paidAt        DateTime?
  status        ExpenseStatus         @default(PENDING)
  paymentMethod ExpensePaymentMethod?
  createdAt     DateTime              @default(now())
  updatedAt     DateTime              @updatedAt
  deletedAt     DateTime?

  user      User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  supplier  Supplier?        @relation(fields: [supplierId], references: [id])
  category  ExpenseCategory? @relation(fields: [categoryId], references: [id])
  workOrder WorkOrder?       @relation(fields: [workOrderId], references: [id])

  @@index([userId])
  @@index([userId, status])
  @@index([userId, dueDate])
  @@index([userId, workOrderId])
  @@index([userId, supplierId])
  @@index([userId, categoryId])
  @@index([userId, deletedAt])
  @@index([paidAt])
  @@map("expenses")
}

// =============================================================================
// INVENTORY MODULE (Controle de Estoque)
// =============================================================================

// Tipo de movimentaÃ§Ã£o de estoque
enum InventoryMovementType {
  ADJUSTMENT_IN   // Entrada manual (compra, devoluÃ§Ã£o, correÃ§Ã£o)
  ADJUSTMENT_OUT  // SaÃ­da manual (perda, correÃ§Ã£o, uso interno)
  WORK_ORDER_OUT  // Baixa automÃ¡tica por OS
  INITIAL         // Saldo inicial ao ativar feature
}

// Fonte da movimentaÃ§Ã£o
enum InventoryMovementSource {
  MANUAL          // Ajuste manual do usuÃ¡rio
  WORK_ORDER      // Baixa por conclusÃ£o de OS
  IMPORT          // ImportaÃ§Ã£o em lote
  SYSTEM          // Ajuste do sistema
}

// ConfiguraÃ§Ãµes de estoque por usuÃ¡rio/empresa
model InventorySettings {
  id                        String          @id @default(uuid())
  userId                    String          @unique
  isEnabled                 Boolean         @default(false)  // Se o controle de estoque estÃ¡ ativo
  deductOnStatus            WorkOrderStatus @default(DONE)   // Em qual status da OS fazer a baixa
  allowNegativeStock        Boolean         @default(false)  // Se permite estoque negativo
  deductOnlyOncePerWorkOrder Boolean        @default(true)   // Prevenir mÃºltiplas baixas na mesma OS
  createdAt                 DateTime        @default(now())
  updatedAt                 DateTime        @updatedAt
  user                      User            @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("inventory_settings")
}

// Saldo atual de cada produto (materializaÃ§Ã£o para consultas rÃ¡pidas)
model InventoryBalance {
  id        String   @id @default(uuid())
  itemId    String   @unique  // Apenas para produtos (type = PRODUCT)
  quantity  Decimal  @db.Decimal(15, 4)  // Saldo atual
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  item      Item     @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@index([itemId])
  @@map("inventory_balances")
}

// Ledger de movimentaÃ§Ãµes - event sourcing para rastreabilidade
model InventoryMovement {
  id            String                  @id @default(uuid())
  itemId        String
  type          InventoryMovementType
  source        InventoryMovementSource
  quantity      Decimal                 @db.Decimal(15, 4)  // Positivo = entrada, Negativo = saÃ­da
  balanceAfter  Decimal                 @db.Decimal(15, 4)  // Saldo apÃ³s a movimentaÃ§Ã£o
  sourceId      String?                 // ID da entidade relacionada (workOrderId, etc)
  notes         String?                 // ObservaÃ§Ãµes do usuÃ¡rio
  createdBy     String?                 // userId que criou a movimentaÃ§Ã£o
  createdAt     DateTime                @default(now())

  // Constraint de idempotÃªncia: impede duplicaÃ§Ã£o de movimentaÃ§Ãµes
  // Para baixas de OS: sourceId = workOrderId, source = WORK_ORDER
  @@unique([itemId, source, sourceId], name: "inventory_movement_idempotency")
  @@index([itemId])
  @@index([source])
  @@index([sourceId])
  @@index([createdAt])
  @@map("inventory_movements")
}

// Controle de idempotÃªncia para baixas de OS
// Registra quais OS jÃ¡ tiveram baixa de estoque processada
model WorkOrderInventoryDeduction {
  id           String    @id @default(uuid())
  workOrderId  String    @unique  // Apenas uma baixa por OS
  deductedAt   DateTime  @default(now())
  itemsCount   Int       // Quantos produtos foram baixados
  notes        String?   // ObservaÃ§Ãµes
  workOrder    WorkOrder @relation(fields: [workOrderId], references: [id], onDelete: Cascade)

  @@index([workOrderId])
  @@index([deductedAt])
  @@map("work_order_inventory_deductions")
}
